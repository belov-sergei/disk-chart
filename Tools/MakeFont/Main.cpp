// Copyright ❤️ 2023-2024, Sergei Belov

#define STB_IMAGE_WRITE_IMPLEMENTATION
#define STB_TRUETYPE_IMPLEMENTATION

#include "Common/Encoding.h"
#include "Filesystem.h"
#include "stb_image_write.h"
#include "stb_truetype.h"

#include <pugixml.hpp>

struct Glyph final {
	Glyph(uint32_t codepoint)
	    : codepoint(codepoint) {}

	bool operator==(const Glyph& other) const {
		return codepoint == other.codepoint;
	}

	uint32_t codepoint = 0;

	int x = 0, y = 0;
	int width = 0, height = 0;
	int offsetX = 0, offsetY = 0;

	float advanceX = 0;

	unsigned char* bitmap = nullptr;
};

// Fonts from which the final texture atlas will be built.
constexpr auto FontPaths = { "Fonts/NotoSans-Regular.ttf", "Fonts/NotoSansSC-Regular.ttf", "Fonts/NotoSansJP-Regular.ttf", "Fonts/NotoSansKR-Regular.ttf" };

int main(int argc, char* argv[]) {
	std::vector<Glyph> glyphCollection;

	// All ASCII characters.
	for (int asciiCode = 0; asciiCode < 127; asciiCode++) {
		auto charGlyph = Glyph(asciiCode);
		glyphCollection.emplace_back(std::move(charGlyph));
	}

	// The font will only include characters that are present in the current texts and translations.
	pugi::xml_document translationDocument;
	std::ignore = translationDocument.load_file("Translations.xml");

	const auto rootElement = translationDocument.document_element();
	for (const auto languageNode : rootElement) {
		for (const auto textNode : languageNode) {
			const auto attribute = textNode.attribute("Value");

			const auto wideCharString = Encoding::MultiByteToWideChar(attribute.as_string());
			for (auto wideChar : wideCharString) {
				Glyph charGlyph = wideChar;

				if (std::find(glyphCollection.begin(), glyphCollection.end(), charGlyph) == glyphCollection.end()) {
					glyphCollection.emplace_back(charGlyph);
				}
			}
		}
	}

	// Area of all glyphs for calculating the atlas size.
	int totalGlyphPixelArea = 0;

	for (const auto* fontPath : FontPaths) {
		const auto fontData = Filesystem::ReadFile<unsigned char>(fontPath);

		stbtt_fontinfo fontInfo;
		stbtt_InitFont(&fontInfo, fontData.data(), stbtt_GetFontOffsetForIndex(fontData.data(), 0));

		const float fontScaling = stbtt_ScaleForPixelHeight(&fontInfo, 18.0f);

		for (auto& glyph : glyphCollection) {
			// Previously found glyphs are skipped.
			if (glyph.bitmap != nullptr) {
				continue;
			}

			if (const auto glyphIndex = stbtt_FindGlyphIndex(&fontInfo, static_cast<int>(glyph.codepoint))) {
				glyph.bitmap = stbtt_GetGlyphBitmap(&fontInfo, fontScaling, fontScaling, glyphIndex, &glyph.width, &glyph.height, &glyph.offsetX, &glyph.offsetY);

				int advanceWidth = 0;
				stbtt_GetGlyphHMetrics(&fontInfo, glyphIndex, &advanceWidth, nullptr);
				glyph.advanceX = static_cast<float>(advanceWidth) * fontScaling;

				totalGlyphPixelArea += glyph.width * glyph.height;
			}
		}
	}

	int atlasWidth = 8;
	int atlasHeight = 8;

	while (atlasWidth * atlasHeight < totalGlyphPixelArea) {
		if (atlasWidth <= atlasHeight) {
			atlasWidth *= 2;
		} else {
			atlasHeight *= 2;
		}
	}

	std::vector<unsigned char> atlasBitmap(static_cast<size_t>(atlasWidth * atlasHeight));

	int x = 0;
	int y = 0;

	int maxGlyphHeight = 0;

	std::ofstream stream("Source/Library/Components/IMGUIFontComponent.Generated.h");
	stream << "// WARNING: This file is automatically generated. Manual changes to this file may be lost.\n\n";
	stream << "#pragma once\n";
	stream << "#include \"IMGUIFontComponent.h\"\n\n";
	stream << "// clang-format off\n";
	stream << "IMGUIFontComponent::Glyph IMGUIFontComponent::Glyphs[] = {\n";

	for (auto& glyph : glyphCollection) {
		if (glyph.width < 1 || glyph.height < 1) {
			continue;
		}

		if (x + glyph.width > atlasWidth) {
			x = 0;
			y += maxGlyphHeight;
			maxGlyphHeight = 0;
		}

		if (y + glyph.height > atlasHeight) {
			std::cerr << "Atlas size is too small!" << std::endl;
			return 0;
		}

		for (int j = 0; j < glyph.height; ++j) {
			for (int i = 0; i < glyph.width; ++i) {
				atlasBitmap[(y + j) * atlasWidth + x + i] = glyph.bitmap[j * glyph.width + i];
			}
		}

		stream << fmt::format("\t{{0, (ImWchar){}, {}, {}, {}, {}, {}f, {{{}, {}}}}},\n", glyph.codepoint, x, y, glyph.width, glyph.height, glyph.advanceX, glyph.offsetX, glyph.offsetY + 11);

		x += glyph.width;
		if (glyph.height > maxGlyphHeight) {
			maxGlyphHeight = glyph.height;
		}
	}

	stream << "};\n";

	int length = 0;
	auto* data = stbi_write_png_to_mem(atlasBitmap.data(), atlasWidth * 1, atlasWidth, atlasHeight, 1, &length);

	stream << "unsigned char IMGUIFontComponent::TextureData[] = {\n\t";
	for (int offset = 0; offset < length; offset++) {
		stream << static_cast<int>(*data++) << ',';

		if (offset > 0 && offset % 50 == 0) {
			stream << "\n\t";
		}
	}

	stream << "\n};\n";
	stream << "// clang-format on\n";

	for (auto& glyph : glyphCollection) {
		stbtt_FreeBitmap(glyph.bitmap, nullptr);
	}

	return 0;
}
