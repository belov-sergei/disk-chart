// Copyright ❤️ 2023-2024, Sergei Belov

#define STB_IMAGE_WRITE_IMPLEMENTATION
#define STB_TRUETYPE_IMPLEMENTATION

#include "Common/Encoding.h"
#include "Filesystem.h"
#include "stb_image_write.h"

#include <ft2build.h>
#include FT_FREETYPE_H

#include <pugixml.hpp>

struct Glyph final {
	Glyph(uint32_t codepoint)
	    : codepoint(codepoint) {}

	bool operator==(const Glyph& other) const {
		return codepoint == other.codepoint;
	}

	uint32_t codepoint = 0;

	int x = 0, y = 0;
	int width = 0, height = 0;
	int offsetX = 0, offsetY = 0;

	float advanceX = 0;

	unsigned char* bitmap = nullptr;
};

// Fonts from which the final texture atlas will be built.
constexpr auto FontPaths = { "Fonts/NotoSans-Regular.ttf", "Fonts/NotoSansSC-Regular.ttf", "Fonts/NotoSansJP-Regular.ttf", "Fonts/NotoSansKR-Regular.ttf" };

int main(int argc, char* argv[]) {
	std::vector<Glyph> glyphCollection;

	// All ASCII characters.
	for (int asciiCode = 0; asciiCode < 127; asciiCode++) {
		auto charGlyph = Glyph(asciiCode);
		glyphCollection.emplace_back(std::move(charGlyph));
	}

	// The font will only include characters that are present in the current texts and translations.
	pugi::xml_document translationDocument;
	std::ignore = translationDocument.load_file("Translations.xml");

	const auto rootElement = translationDocument.document_element();
	for (const auto languageNode : rootElement) {
		for (const auto textNode : languageNode) {
			const auto attribute = textNode.attribute("Value");

			const auto wideCharString = Encoding::MultiByteToWideChar(attribute.as_string());
			for (auto wideChar : wideCharString) {
				Glyph charGlyph = wideChar;

				if (std::find(glyphCollection.begin(), glyphCollection.end(), charGlyph) == glyphCollection.end()) {
					glyphCollection.emplace_back(charGlyph);
				}
			}
		}
	}

	FT_Library library;
	FT_Error error = FT_Init_FreeType(&library);

	// Area of all glyphs for calculating the atlas size.
	int totalGlyphPixelArea = 0;

	for (const auto* font : FontPaths) {
		FT_Face face;
		error = FT_New_Face(library, font, 0, &face);
		error = FT_Set_Pixel_Sizes(face, 0, 13);

		for (auto& glyph : glyphCollection) {
			// Previously found glyphs are skipped.
			if (glyph.bitmap != nullptr) {
				continue;
			}

			if (const FT_UInt glyphIndex = FT_Get_Char_Index(face, glyph.codepoint)) {
				error = FT_Load_Glyph(face, glyphIndex, FT_LOAD_DEFAULT);
				error = FT_Render_Glyph(face->glyph, FT_RENDER_MODE_NORMAL);

				FT_GlyphSlot slot = face->glyph;

				unsigned int size = slot->bitmap.width * slot->bitmap.rows;
				glyph.bitmap = new unsigned char[size];

				memcpy(glyph.bitmap, slot->bitmap.buffer, size);

				glyph.width = slot->bitmap.width;
				glyph.height = slot->bitmap.rows;
				glyph.offsetX = slot->bitmap_left;
				glyph.offsetY = slot->bitmap_top;
				glyph.advanceX = slot->advance.x >> 6;

				totalGlyphPixelArea += size;
			}
		}
	}

	int atlasWidth = 8;
	int atlasHeight = 8;

	while (atlasWidth * atlasHeight < totalGlyphPixelArea) {
		if (atlasWidth <= atlasHeight) {
			atlasWidth *= 2;
		} else {
			atlasHeight *= 2;
		}
	}

	std::vector<unsigned char> atlasBitmap(static_cast<size_t>(atlasWidth * atlasHeight));

	int x = 0;
	int y = 0;

	int maxGlyphHeight = 0;

	std::ofstream stream("Source/Library/Components/IMGUIFontComponent.Generated.h");
	stream << "// WARNING: This file is automatically generated. Manual changes to this file may be lost.\n\n";
	stream << "#pragma once\n";
	stream << "#include \"IMGUIFontComponent.h\"\n\n";
	stream << "// clang-format off\n";
	stream << "IMGUIFontComponent::Glyph IMGUIFontComponent::Glyphs[] = {\n";

	for (auto& glyph : glyphCollection) {
		if (glyph.width < 1 || glyph.height < 1) {
			continue;
		}

		if (x + glyph.width > atlasWidth) {
			x = 0;
			y += maxGlyphHeight;
			maxGlyphHeight = 0;
		}

		if (y + glyph.height > atlasHeight) {
			std::cerr << "Atlas size is too small!" << std::endl;
			return 0;
		}

		for (int j = 0; j < glyph.height; ++j) {
			for (int i = 0; i < glyph.width; ++i) {
				atlasBitmap[(y + j) * atlasWidth + x + i] = glyph.bitmap[j * glyph.width + i];
			}
		}

		stream << fmt::format("\t{{0, (ImWchar){}, {}, {}, {}, {}, {}, {{{}, {}}}}},\n", glyph.codepoint, x, y, glyph.width, glyph.height, glyph.advanceX, glyph.offsetX, -glyph.offsetY + 11);

		x += glyph.width;
		if (glyph.height > maxGlyphHeight) {
			maxGlyphHeight = glyph.height;
		}
	}

	stream << "};\n";

	int length = 0;
	auto* data = stbi_write_png_to_mem(atlasBitmap.data(), atlasWidth * 1, atlasWidth, atlasHeight, 1, &length);

	// stbi_write_png("Test.png", atlasWidth, atlasHeight, 1, atlasBitmap.data(), atlasWidth * 1);

	stream << "unsigned char IMGUIFontComponent::TextureData[] = {\n\t";
	for (int offset = 0; offset < length; offset++) {
		stream << static_cast<int>(*data++) << ',';

		if (offset > 0 && offset % 50 == 0) {
			stream << "\n\t";
		}
	}

	stream << "\n};\n";
	stream << "// clang-format on\n";

	for (auto& glyph : glyphCollection) {
		delete [] glyph.bitmap;
	}

	return 0;
}
